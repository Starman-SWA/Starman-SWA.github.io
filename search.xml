<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>写点什么</title>
    <url>/2020/12/28/%E5%86%99%E7%82%B9%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<p>凌晨1:50，刚刚搭完博客。</p>
<p>不知道度过了多少个碌碌无为的日日夜夜，不知道自己所追求的虚无缥缈的目标到底有什么意义，梦想这个词似乎与我渐行渐远，我也早已不再是某位长辈口中的那个“愣头青”了。</p>
<p>至于为什么，是经历？是年龄？是环境？我也说不准。或许现在的我才是真正的我，而以前的我只不过是被戴上面具罢了吧。</p>
<p>不管如何，今天也算是个新的开始。</p>
<p>Hello world!</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>区间调度问题</title>
    <url>/2020/12/28/%E5%8C%BA%E9%97%B4%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="一、区间不相交问题"><a href="#一、区间不相交问题" class="headerlink" title="一、区间不相交问题"></a>一、区间不相交问题</h2><blockquote>
<p>给出N个开区间(start, end)，从中选择尽可能多的区间，使得这些区间两两不相交。</p>
</blockquote>
<p>解决思路是将区间集合S中的所有区间按照end值从小到大的顺序进行排序，然后执行下列步骤：</p>
<ol>
<li>从区间集合S中选取end值最小的区间i，将i加入区间集合T。</li>
<li>寻找与i相交的所有区间，将这些区间从集合S中删除。</li>
<li>若S非空，跳转到步骤1。</li>
</ol>
<p>区间T即为所求。</p>
<p>证明思路可以考虑反证法：假设某一次选择的i的end值并不是集合S中最大的，如果存在与区间i相交且end值更小的区间i’，则选择i’所移除的区间数不会大于选择i所移除的区间数，此时选取end值更小的i’会使局部结果更优。</p>
<a id="more"></a>

<p>实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mostDisjointIntervals</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (intervals.empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    sort(intervals.begin(), intervals.end(), cmp);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; intervals.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 找到第一个不与intervals[i]相交的区间intervals[j]</span></span><br><span class="line">        <span class="keyword">while</span> (j &lt; intervals.size() &amp;&amp; intervals[j][<span class="number">0</span>] &lt; intervals[i][<span class="number">1</span>] )</span><br><span class="line">            ++j;</span><br><span class="line">        ++count;</span><br><span class="line">        i = j;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、应用1：LeetCode-435-无重叠区间"><a href="#二、应用1：LeetCode-435-无重叠区间" class="headerlink" title="二、应用1：LeetCode 435 无重叠区间"></a>二、应用1：LeetCode 435 无重叠区间</h2><blockquote>
<p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p>
</blockquote>
<p>移除的最小区间数量就是区间总数减去剩余的最大区间数量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> intervals.size() - mostDisjointIntervals(intervals);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、应用2：LeetCode-452-用最少数量的箭引爆气球"><a href="#三、应用2：LeetCode-452-用最少数量的箭引爆气球" class="headerlink" title="三、应用2：LeetCode 452 用最少数量的箭引爆气球"></a>三、应用2：LeetCode 452 用最少数量的箭引爆气球</h2><blockquote>
<p>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。</p>
<p>一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p>
<p>给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。</p>
</blockquote>
<p>在区间不相交问题中，每当选取一个区间时，与其相交的区间也会被移除。这相当于在本问题中，每射爆一个气球，与其相重叠的气球也会被射爆。因此两个问题是等价的，可以套用前面的代码，只不过本题中的区间是闭区间而不是开区间，需要修改边界条件。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mostDisjointIntervals</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> (i &lt; intervals.size())</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 将小于号改为小于等于号</span></span><br><span class="line">        <span class="keyword">while</span> (j &lt; intervals.size() &amp;&amp; intervals[j][<span class="number">0</span>] &lt;= intervals[i][<span class="number">1</span>] )</span><br><span class="line">            ++j;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、变形1：LeetCode-56-合并区间"><a href="#四、变形1：LeetCode-56-合并区间" class="headerlink" title="四、变形1：LeetCode 56 合并区间"></a>四、变形1：LeetCode 56 合并区间</h2><blockquote>
<p>给出一个区间的集合，请合并所有重叠的区间。</p>
</blockquote>
<p>本题仍是与区间重叠相关的问题，但是与上面三题有一点不同。上面三题的重叠区间是以某一个区间为参照的，也就是说所有的区间都必须与某一个特定的区间重叠。但是这一题不需要，对于所要合并的区间集合中的每一个区间，只需要与集合中的任意一个区间重叠即可。</p>
<p>本题的算法核心仍是贪心，但是需要做出一点调整：对区间集合使用字典排序，即先比较start，按照start升序排列，若start值相同，再按end升序排列。这样排序的目的是使所有能够进行合并的区间相邻。排序后，从前往后遍历区间，将尽可能多的相邻的重叠区间合并成一个大区间。对于每个合并后的大区间，其start值就是最左侧的小区间的start，其end值是所有小区间当中end值最大的那个。故在遍历期间，需要维护变量maxEnd存储end值的最大值。</p>
<p>题解如下，可见代码在上述三题的基础上修改了比较函数、内层循环的条件以及增加了maxEnd变量的维护：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a[<span class="number">0</span>] &gt; b[<span class="number">0</span>])</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a[<span class="number">0</span>] &lt; b[<span class="number">0</span>])</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a[<span class="number">1</span>] &lt; b[<span class="number">1</span>])</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; merge(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">if</span> (intervals.empty())</span><br><span class="line">    	<span class="keyword">return</span> ans;</span><br><span class="line">    sort(intervals.begin(), intervals.end(), cmp);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; intervals.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> maxEnd = intervals[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 找到第一个不与intervals[i]相交的区间intervals[j]</span></span><br><span class="line">        <span class="keyword">while</span> (j &lt; intervals.size() &amp;&amp; intervals[j][<span class="number">0</span>] &lt;= maxEnd)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[j][<span class="number">1</span>] &gt; maxEnd)</span><br><span class="line">            maxEnd = intervals[j][<span class="number">1</span>];</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;  </span><br><span class="line">        ans.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &#123;intervals[i][<span class="number">0</span>], maxEnd&#125;);</span><br><span class="line">        i = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、变形2：LeetCode-57-插入区间"><a href="#五、变形2：LeetCode-57-插入区间" class="headerlink" title="五、变形2：LeetCode 57 插入区间"></a>五、变形2：LeetCode 57 插入区间</h2><blockquote>
<p>给出一个<em>无重叠的 ，</em>按照区间起始端点排序的区间列表。</p>
<p>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</p>
</blockquote>
<p>这道题的难度为“困难”，但是相比之前的几道题目其实反而不需要用到什么特别的算法，只需从左到右遍历区间集合，找到新区间的插入位置并进行（可能的）合并操作。题目给的区间集合是<strong>无重叠</strong>的，因此省去了存储maxEnd的步骤，只需考虑边界条件进行适当的分类讨论即可。我的代码较为复杂，还可以进一步简化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; insert(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; newInterval)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">if</span> (intervals.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        ans.push_back(newInterval);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> inserted = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; intervals.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!inserted)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (newInterval[<span class="number">0</span>] &gt; intervals[i][<span class="number">1</span>])</span><br><span class="line">                ans.push_back(intervals[i++]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (newInterval[<span class="number">1</span>] &gt;= intervals[i][<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; intervals.size() &amp;&amp; intervals[j][<span class="number">0</span>] &lt;= newInterval[<span class="number">1</span>])</span><br><span class="line">                    ++j;</span><br><span class="line">                <span class="keyword">int</span> newStart = min(newInterval[<span class="number">0</span>], intervals[i][<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">if</span> (j == i + <span class="number">1</span>)</span><br><span class="line">                    ans.push_back(&#123;newStart, max(intervals[i][<span class="number">1</span>], newInterval[<span class="number">1</span>])&#125;);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ans.push_back(&#123;newStart, max(intervals[j - <span class="number">1</span>][<span class="number">1</span>], newInterval[<span class="number">1</span>])&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                inserted = <span class="literal">true</span>;</span><br><span class="line">                i = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ans.push_back(newInterval);</span><br><span class="line">                ans.push_back(intervals[i++]);</span><br><span class="line">                inserted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans.push_back(intervals[i++]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!inserted)</span><br><span class="line">        ans.push_back(newInterval);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>两道求最大面积的题目在解法上的不同</title>
    <url>/2021/01/01/%E4%B8%A4%E9%81%93%E6%B1%82%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF%E7%9A%84%E9%A2%98%E7%9B%AE%E5%9C%A8%E8%A7%A3%E6%B3%95%E4%B8%8A%E7%9A%84%E4%B8%8D%E5%90%8C/</url>
    <content><![CDATA[<p>今天发现两道看似十分相似但实际上有很大不同的题目，差点转不过弯来，分别是<strong>LeetCode 11 盛最多水的容器</strong>和<strong>LeetCode 84 柱状图中最大的矩形</strong>。</p>
<p><strong>LeetCode 11 盛最多水的容器</strong></p>
<blockquote>
<p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>说明：你不能倾斜容器。</p>
</blockquote>
<p><strong>LeetCode 84 柱状图中最大的矩形</strong></p>
<blockquote>
<p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
</blockquote>
<a id="more"></a>

<p>我先写了84题，再回过头写11题时，以为两道题的区别就是柱状图和“挡板”的区别，还是用单调栈的方法，只需在求面积的时候做一点小修改即可。</p>
<p>先看84题。从左往右遍历柱状图的每一个柱形，若当前遍历到的柱形比上一个柱形高，则无法确定以上一个柱形的高为高的最大矩形面积，因为矩形可以越过当前柱形，一直延伸到右边，而右边的情况还不知道；反之，若当前遍历到的柱形比上一个柱形低，则以上一个柱形的高为高的矩形肯定无法越过当前柱形，又因为其左侧所有柱形已经遍历过了，所以矩形能够延伸到的左右两边的极限都可以确定，以上一个柱形的高为高的最大矩形面积也确定下来了。实际上，以当前柱形左侧的所有比当前柱形高的柱形的高为高的最大矩形面积都可以确定下来了。上述算法可以通过栈实现，栈中依次存储所有以第i个柱形为高的矩形的最大面积还未确定时的i值。</p>
<p>解决了第84题，我把代码套到第11题的时候发现无论我怎么修改边界条件，得出来的结果与答案都相去甚远。再次读题目的时候发现两道题有一个很大的不同：在第11题中，若确定了左右边界i、j，则所得矩形的高为min{height[i], height[j]}，换言之，<strong>水可以漫过挡板i、j中间的挡板</strong>；但在第84题中，所得矩形的高还受柱形i、j中间的柱形的限制，其值为min{height[i], height[i + 1], …, height[j - 1], height[j]}，换言之，<strong>柱形相当于容器，水不能超出容器，而且水的形状必须是矩形，可以将其理解为“冰块”</strong>。</p>
<p>因此，第11题只要确定了左右边界i、j，就可以确定矩形的面积，故遍历时使用双指针即可。</p>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
</search>
