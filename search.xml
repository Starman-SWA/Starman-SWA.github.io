<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>写点什么</title>
    <url>/2020/12/28/%E5%86%99%E7%82%B9%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<p>凌晨1:50，刚刚搭完博客。</p>
<p>不知道度过了多少个碌碌无为的日日夜夜，不知道自己所追求的虚无缥缈的目标到底有什么意义，梦想这个词似乎与我渐行渐远，我也早已不再是某位长辈口中的那个“愣头青”了。</p>
<p>至于为什么，是经历？是年龄？是环境？我也说不准。或许现在的我才是真正的我，而以前的我只不过是被戴上面具罢了吧。</p>
<p>不管如何，今天也算是个新的开始。</p>
<p>Hello world!</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>区间调度问题</title>
    <url>/2020/12/28/%E5%8C%BA%E9%97%B4%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="一、区间不相交问题"><a href="#一、区间不相交问题" class="headerlink" title="一、区间不相交问题"></a>一、区间不相交问题</h2><blockquote>
<p>给出N个开区间(start, end)，从中选择尽可能多的区间，使得这些区间两两不相交。</p>
</blockquote>
<p>解决思路是将区间集合S中的所有区间按照end值从小到大的顺序进行排序，然后执行下列步骤：</p>
<ol>
<li>从区间集合S中选取end值最小的区间i，将i加入区间集合T。</li>
<li>寻找与i相交的所有区间，将这些区间从集合S中删除。</li>
<li>若S非空，跳转到步骤1。</li>
</ol>
<p>区间T即为所求。</p>
<p>证明思路可以考虑反证法：假设某一次选择的i的end值并不是集合S中最大的，如果存在与区间i相交且end值更小的区间i’，则选择i’所移除的区间数不会大于选择i所移除的区间数，此时选取end值更小的i’会使局部结果更优。</p>
<a id="more"></a>

<p>实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mostDisjointIntervals</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (intervals.empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    sort(intervals.begin(), intervals.end(), cmp);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; intervals.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 找到第一个不与intervals[i]相交的区间intervals[j]</span></span><br><span class="line">        <span class="keyword">while</span> (j &lt; intervals.size() &amp;&amp; intervals[j][<span class="number">0</span>] &lt; intervals[i][<span class="number">1</span>] )</span><br><span class="line">            ++j;</span><br><span class="line">        ++count;</span><br><span class="line">        i = j;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、应用1：LeetCode-435-无重叠区间"><a href="#二、应用1：LeetCode-435-无重叠区间" class="headerlink" title="二、应用1：LeetCode 435 无重叠区间"></a>二、应用1：LeetCode 435 无重叠区间</h2><blockquote>
<p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p>
</blockquote>
<p>移除的最小区间数量就是区间总数减去剩余的最大区间数量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> intervals.size() - mostDisjointIntervals(intervals);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、应用2：LeetCode-452-用最少数量的箭引爆气球"><a href="#三、应用2：LeetCode-452-用最少数量的箭引爆气球" class="headerlink" title="三、应用2：LeetCode 452 用最少数量的箭引爆气球"></a>三、应用2：LeetCode 452 用最少数量的箭引爆气球</h2><blockquote>
<p>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。</p>
<p>一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p>
<p>给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。</p>
</blockquote>
<p>在区间不相交问题中，每当选取一个区间时，与其相交的区间也会被移除。这相当于在本问题中，每射爆一个气球，与其相重叠的气球也会被射爆。因此两个问题是等价的，可以套用前面的代码，只不过本题中的区间是闭区间而不是开区间，需要修改边界条件。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mostDisjointIntervals</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> (i &lt; intervals.size())</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 将小于号改为小于等于号</span></span><br><span class="line">        <span class="keyword">while</span> (j &lt; intervals.size() &amp;&amp; intervals[j][<span class="number">0</span>] &lt;= intervals[i][<span class="number">1</span>] )</span><br><span class="line">            ++j;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、变形1：LeetCode-56-合并区间"><a href="#四、变形1：LeetCode-56-合并区间" class="headerlink" title="四、变形1：LeetCode 56 合并区间"></a>四、变形1：LeetCode 56 合并区间</h2><blockquote>
<p>给出一个区间的集合，请合并所有重叠的区间。</p>
</blockquote>
<p>本题仍是与区间重叠相关的问题，但是与上面三题有一点不同。上面三题的重叠区间是以某一个区间为参照的，也就是说所有的区间都必须与某一个特定的区间重叠。但是这一题不需要，对于所要合并的区间集合中的每一个区间，只需要与集合中的任意一个区间重叠即可。</p>
<p>本题的算法核心仍是贪心，但是需要做出一点调整：对区间集合使用字典排序，即先比较start，按照start升序排列，若start值相同，再按end升序排列。这样排序的目的是使所有能够进行合并的区间相邻。排序后，从前往后遍历区间，将尽可能多的相邻的重叠区间合并成一个大区间。对于每个合并后的大区间，其start值就是最左侧的小区间的start，其end值是所有小区间当中end值最大的那个。故在遍历期间，需要维护变量maxEnd存储end值的最大值。</p>
<p>题解如下，可见代码在上述三题的基础上修改了比较函数、内层循环的条件以及增加了maxEnd变量的维护：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a[<span class="number">0</span>] &gt; b[<span class="number">0</span>])</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a[<span class="number">0</span>] &lt; b[<span class="number">0</span>])</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a[<span class="number">1</span>] &lt; b[<span class="number">1</span>])</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; merge(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">if</span> (intervals.empty())</span><br><span class="line">    	<span class="keyword">return</span> ans;</span><br><span class="line">    sort(intervals.begin(), intervals.end(), cmp);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; intervals.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> maxEnd = intervals[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 找到第一个不与intervals[i]相交的区间intervals[j]</span></span><br><span class="line">        <span class="keyword">while</span> (j &lt; intervals.size() &amp;&amp; intervals[j][<span class="number">0</span>] &lt;= maxEnd)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[j][<span class="number">1</span>] &gt; maxEnd)</span><br><span class="line">            maxEnd = intervals[j][<span class="number">1</span>];</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;  </span><br><span class="line">        ans.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &#123;intervals[i][<span class="number">0</span>], maxEnd&#125;);</span><br><span class="line">        i = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、变形2：LeetCode-57-插入区间"><a href="#五、变形2：LeetCode-57-插入区间" class="headerlink" title="五、变形2：LeetCode 57 插入区间"></a>五、变形2：LeetCode 57 插入区间</h2><blockquote>
<p>给出一个<em>无重叠的 ，</em>按照区间起始端点排序的区间列表。</p>
<p>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</p>
</blockquote>
<p>这道题的难度为“困难”，但是相比之前的几道题目其实反而不需要用到什么特别的算法，只需从左到右遍历区间集合，找到新区间的插入位置并进行（可能的）合并操作。题目给的区间集合是<strong>无重叠</strong>的，因此省去了存储maxEnd的步骤，只需考虑边界条件进行适当的分类讨论即可。我的代码较为复杂，还可以进一步简化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; insert(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; newInterval)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">if</span> (intervals.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        ans.push_back(newInterval);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> inserted = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; intervals.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!inserted)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (newInterval[<span class="number">0</span>] &gt; intervals[i][<span class="number">1</span>])</span><br><span class="line">                ans.push_back(intervals[i++]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (newInterval[<span class="number">1</span>] &gt;= intervals[i][<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; intervals.size() &amp;&amp; intervals[j][<span class="number">0</span>] &lt;= newInterval[<span class="number">1</span>])</span><br><span class="line">                    ++j;</span><br><span class="line">                <span class="keyword">int</span> newStart = min(newInterval[<span class="number">0</span>], intervals[i][<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">if</span> (j == i + <span class="number">1</span>)</span><br><span class="line">                    ans.push_back(&#123;newStart, max(intervals[i][<span class="number">1</span>], newInterval[<span class="number">1</span>])&#125;);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ans.push_back(&#123;newStart, max(intervals[j - <span class="number">1</span>][<span class="number">1</span>], newInterval[<span class="number">1</span>])&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                inserted = <span class="literal">true</span>;</span><br><span class="line">                i = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ans.push_back(newInterval);</span><br><span class="line">                ans.push_back(intervals[i++]);</span><br><span class="line">                inserted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans.push_back(intervals[i++]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!inserted)</span><br><span class="line">        ans.push_back(newInterval);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
</search>
